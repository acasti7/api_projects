-- This is following an example for django api project --
# Medium Tutorial: https://medium.com/django-unleashed/maximizing-chatbot-performance-elevating-user-experiences-through-efficient-conversation-915f341097c1
## Primitives...
# Setup python environment, and activate
python3 -m venv llm_api_env
source ./llm_api_env/bin/activate
pip install -r requirements.txt
## note, using pip-chill, can make referencing packages very easy...
pip install pip-chill
pip-chill --no-version > requirements.txt

##A. Setup Django project and app named chat and authentication
# in terminal
1. django-admin startproject <your_project_name>
2. cd <your_project_name>
3. python manage.py startapp chat
4. python manage.py startapp authentication
-- Note the api is setup into logical applications, chat, and authentication

##B. Set the configurations necessary in the project folder.
# in ./langchain_openai_api/settings.py
1. add applications to "installed_apps" variable += 
    ['rest_framework', #specified that we are using rest framework
     'rest_framework.authtoken', #used for token authentication
     'chat', #added name of our new app
     'authentication', #for registering users and providing tokens]
2.  set: CORS_ALLOW_ALL_ORIGINS = True 
    --What CORS_ALLOW_ALL_ORIGINS = True Does:
        This setting allows all domain origins to access your resources without any restrictions. 
        It's part of Django's CORS headers setup, typically managed by a package like django-cors-headers.
3. set: ALLOWED_HOSTS = ['*']
    --Development: In local development environments, setting ALLOWED_HOSTS = ['*'] allows for flexibility, 
        as requests can be sent from any host.
    --Deployment: In production, it's often used temporarily when the deployment environment is not fully 
        known or when configuring a new server. However, it should be configured to more specific host names 
        once the deployment details are finalized.


##C. Setup the authentication serializer, views & urls ###
 --In Django REST framework, a serializer serves as an intermediary component responsible for 
    converting complex data types (such as querysets or model instances) into native Python 
    datatypes that can then be easily rendered into JSON, XML, or other content types. 
    Additionally, it helps in deserializing data received from the client back into complex 
    data types.
# in ./authentication/serializers.py
1. Utilizer Django's Built-in "User" Model:
    Django provides a default "User" model in its "django.contrib.auth.models" module. 
    This model is designed to handle common user-related tasks in web applications, 
    such as authentication and authorization.
2. Setup Serializer for Django REST Framework and User Model:
    When you use Django REST Framework (DRF) to create APIs, you often need to serialize and 
    deserialize the User model data. The UserSerializer class you've shown is an example of how 
    you can extend "serializers.ModelSerializer" to work with Django's built-in "User" model.
# in ./authentication/views.py
3. Create a Django view function that handles authentication-related tasks using Django REST Framework (DRF).
    The view: "auth" :  this view function handles a POST request containing JSON data for user 
    registration. It parses the JSON data, validates it using a serializer, and saves 
    the data if it's valid, returning appropriate JSON responses based on the outcome.
    --> this code creates a new user upon requesting a JSON object with keys username and password.
# in ./authentication/urls.py
4. create a ./authentication/urls.py file and define the route patterns
    --> in this file we define the routes to:
    1. Handle Requests to "/get-auth/" are handled by Django REST Framework's built-in view for obtaining authentication tokens.
        -->  'obtain_auth_token' function from 'rest_framework.authentication.views'
    2. Handle Requests to "/register/" are handled by the custom auth function defined locally in the views module. This function
     appears to handle user registration/authentication logic as per the provided code snippet.


##D. Setup data model for conversation and chat messages ##
# in ./chat/models.py
1. Create Data Models for ChatMessage, and Conversation, using the 'model.Model' class
2. The models leverage the built in django user data model, the entities are structured as below:
    ###-User (pk->id) --> Note, Built In django Data Model with multiple fields e.g., id, username, password, groups, email, is_active,
    ###-Conversation (pk->id, fk->User.id) --> note "id" is an autogenerated field
    ###-ChatMessage (pk->id, fk->Conversation.id)  --> since no primary key is explicitly defined in the "Conversation" model, Django automatically creates an id field which acts as the primary key. So, the conversation ForeignKey in ChatMessage essentially points to this id field of the Conversation model.
3. Here Conversation object is specific for every user and stores conversations with ‘title’ as a primary key. ChatMessage object stores 
    all conversation history related to a specific conversation. It uses ‘title’ as a foreign key.
    Whenever a user wants to retrieve a specific conversation he queries with the title of the 
    conversation and he gets all chat messages related to it.
4. Create serializers, which handle APII requests converting back and forth between JSON and useable python data types
    # a. create ./chat/serializers.py
    # b. in ./chat/serializers.py, create serializers for 'ChatMessageSerializer',
        and 'ChatMessageSerializer' using the 'serializers.ModelSerializer' base class

## E. Create views for the chat application ##
### Documentation under constructoin


## F. Create urls for chat app
# create ./chat/urls.py
# in ./chat/urls.py


## G. Create urls for main application
# create ./urls.py
# in ./urls.py

## H. Deploy Django API on server
# in terminal at top level directory
python manage.py makemigrations #creates the sql commands for tables
python manage.py migrate #creates db tables
python manage.py runserver #run the app

## I. Execute API calls against created API
see Postman files in "django_langchain_api" 
